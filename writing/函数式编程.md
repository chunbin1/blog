# 函数式编程

## 函数式编程的思想

函数式编程是一种编程范式，他有以下一些思想

### 函数是一等公民

我的理解就是能用函数就用函数，函数可以做参数、变量、返回值.
举个栗子，比如我们要对数组进行排序

```js
const arr = [1,3,4,2,1]

// 例1：不够好
arr.sort((a,b)=>{
  return a - b
})

// 例2：好
function compare(a,b){
  return a - b
}
arr.sort(compare)
```
为什么方法2比较好？
从复用性的角度来说,当我们很多地方需要使用同样的方法进行排序，那么我们直接引入compare方法即可。
```js
import {compare} from '@/utils'
const arr2 = [1,2,3,4]
arr2.sort(compare)
```
从维护性的角度来说，当我们的需求变动,我们只需要修改compare里面即可，或者使用别的compare方法。
比如换个需求变动，更换排序方式为倒置，我们只要很方便的修改`sort`的入参即可
```js
// 倒置数组
function reverse(){
  return -1
}
arr.sort(reverse)
```


### 纯函数

这是一个数学概念，f(x) = y，纯函数指 x 输入一致，那么 y 也一致。
举个例子：

```js
// 纯函数
const pureFn = (x) => {
  let i = 1;
  return x + i;
};

// 不是纯函数
let i = 1;
const notPureFn = (x) => {
  return x + i;
};
```

例子 1 是纯函数，因为当 x 一致，返回永远；
例子 2 不是纯函数，`notPureFn`依赖了`外部变量i`,如果这个时候程序外部改变了 i 那么返回的结果就不一致；

#### 纯函数的优点

我们从函数的定义可以不难得出纯函数的几个优点

1. 易于单元测试

```js
function sum(a, b) {
  return a + b;
}

test("adds 1 + 2 to equal 3", () => {
  expect(sum(1, 2)).toBe(3);
});
```

因为纯函数`不依赖外部环境`,我们可以方便的写出单元测试，不需要为单元测试增加外部环境。

2. 易于重构
   因为可以很方便的增加单元测试，重构过程中可以减少很多理解成本

3. bug 可控
   因为纯函数不影响外部环境，产生 bug 影响面小。

#### 如何写代码

我们应该要`多写纯函数，少写非纯函数`。

### 副作用

副作用指函数内部和外部的交互，比如:

- 发起 http 请求
- 使用外部变量
- 数据库读写
  等等

函数式编程要求我们通过拆分，减少副作用函数
